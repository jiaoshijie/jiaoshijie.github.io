<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C | Jsj's Blog</title>
<meta name=keywords content><meta name=description content="Jiao shijie's blog"><meta name=author content="Jiao shijie"><link rel=canonical href=https://jiaoshijie.github.io/tags/c/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.611cf8c8c671ee20d7166886b78e57ad24c8123fb1dc0fde4edee77b5f66d2e2.css integrity="sha256-YRz4yMZx7iDXFmiGt45XrSTIEj+x3A/eTt7ne19m0uI=" rel="preload stylesheet" as=style><link rel=icon href=https://jiaoshijie.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jiaoshijie.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://jiaoshijie.github.io/favicon.ico><link rel=apple-touch-icon href=https://jiaoshijie.github.io/favicon.ico><link rel=mask-icon href=https://jiaoshijie.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jiaoshijie.github.io/tags/c/index.xml><link rel=alternate hreflang=zh-cn href=https://jiaoshijie.github.io/tags/c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C"><meta property="og:description" content="Jiao shijie's blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jiaoshijie.github.io/tags/c/"><meta property="og:site_name" content="Jsj's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="C"><meta name=twitter:description content="Jiao shijie's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiaoshijie.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://jiaoshijie.github.io/favicon.ico alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiaoshijie.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiaoshijie.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://jiaoshijie.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiaoshijie.github.io/tags/>Tags</a></div><h1>C
<a href=/tags/c/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C 语言函数调用和VLA和alloca栈的变化探讨</h2></header><div class=entry-content><p>NOTE: 以下讨论使用的平台为 x86-64，使用的编译器为 gcc，以下提供的伪汇编码 采用 intel 格式。
文章中提到的代码，可以在 Code 找到。
一些重要的寄存器和指令 函数调用过程中，比较重要的寄存器主要有三个 rip rbp rsp。
rip 寄存器存放的为下一条要执行指令的地址，Instruction Pointer。 rbp 为基寄存器，存放的为前一个 rbp 的值，Base Pointer。 rsp 为栈寄存器，一直指向函数调用栈的底部，Stack Pointer。 比较重要的指令有 call push pop leave ret。
call addr 指令会首先将 call 返回之后要执行的地址压入栈中(返回地址)，设置 rip 的值为 addr，然后跳转的这个位置去执行，大致可以等效于一下指令。
# 假设当执行到 call 指令时 CPU 就会自动设置 rip 寄存器为下一条要执行的指令 push rip mov rip, addr # 按理设置了 rip 寄存器，CPU 就会去执行 rip 地址的指令，这里写 jmp 只是想要更清晰的表示 call 的流程 jmp addr push rbp 指令会将 rsp 寄存器下移一个 word 的长度，rbp 中的内容移动到 rsp 寄存器所指向的地址中。
...</p></div><a class=entry-link aria-label="post link to C 语言函数调用和VLA和alloca栈的变化探讨" href=https://jiaoshijie.github.io/posts/function_call_and_vla_and_alloca/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>阅读 Linux 核心源代码 lib/list_sort.c</h2></header><div class=entry-content><p>Linux 核心代码中，对链表的排序算法是一种归并排序的变种。采用的排序方式为自下而上 的排序，这种方式可以避免 cache thrashing。
合并时机 Linux 中的对归并排序的改进主要是改变了两个链表的合并时机。该算法会有一个 pending 链表用来记录排序好的子链表，且保证每个子链表的长度都为 $2^k$。当 pending 中 即将出现第三个 $2^k$ 长度的链表时，就会合并已存在的两个 $2^k$ 长度的链表使其 变为一个 $2^{k+1}$ 长度的链表，所以在 pending 链表中永远不会存在超过 2 个 长度为 $2^k$ 的链表。
使用一个变量 count 来追踪 pending 中 $2^k$ 长度链表的个数，可以通过 count 中 k+1 k k-1 这 3 个 bits 来确定 pending 中 $2^k$ 长度链表的个数。下表 中的 3 个 bits 分别表示 k+1 k k-1，当 k 为 0 时，认为 -1 bit 为 1。
count $2^k$ 长度链表个数 …000… 0 …001… 0 …010… 0 …011… 1 …100… 1 …101… 2 源码分析 __attribute__((nonnull(2,3))) void list_sort(void *priv, struct list_head *head, list_cmp_func_t cmp) { struct list_head *list = head->next, *pending = NULL; size_t count = 0; /* Count of pending */ if (list == head->prev) /* Zero or one elements */ return; /* Convert to a null-terminated singly-linked list. */ head->prev->next = NULL; // .... } 函数的参数：
...</p></div><a class=entry-link aria-label="post link to 阅读 Linux 核心源代码 lib/list_sort.c" href=https://jiaoshijie.github.io/posts/reading_linux_source_code_about_lib_list_sort_c/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>快速计算正整数的平方根</h2></header><div class=entry-content><p>如何求一个正整数的平方根，最直接的方法就是
int i_sqrt(int N) { int res = 1; while (res * res &lt;= N) { res++; } return res - 1; } 但上面的计算方法非常的低效，而对于求正整数的平方根，已经有非常多的算法。
下面介绍一个常用的正整数开平方根的算法。
Digit by digit calculation Digit by digit calculation
假设 $x = \sqrt{N}$ 则 $x^2 = N$ 以二进制表示 $x$，则 $x^2$ 为
$$ x^2 = (000b_0b_1b_2 \cdots b_{n-1}b_n)^2 \tag{1} $$
其中，$b_0$ 为 $x$ 的二进制表示中第一个为 1 的二进制位。但要注意 $b_1 \cdots b_n$ 并不一定全为 1。我们可以将公式 (1) 改为加法形式。$a_n$ 对应的为 $b_0$。
$$ x^2 = (a_n + a_{n-1} + \cdots + a_1 + a_0)^2 \tag{2} $$
其中，$a_m = 2^m$ 或 $a_m = 0$，取决于对应二进制位的值为 1 还是 0。将其展开可以得到
...</p></div><a class=entry-link aria-label="post link to 快速计算正整数的平方根" href=https://jiaoshijie.github.io/posts/quick_clac_square_root/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>关于数组array和&amp;array地址相同问题</h2></header><div class=entry-content><p>文中代码
对于如下代码:
int array[] = { 0, 1, 2, 3, 4 }; printf("%p\n", &amp;array); printf("%p\n", array); 可以看到输出的地址是相同的.
而对于如下代码:
int **array = (int **)malloc(sizeof(int *) * 5); for (int i = 0; i &lt; 5; i++) array[i] = (int *)malloc(sizeof(int)); printf("%p\n", &amp;array); printf("%p\n", array); 可以看到输出的地址是不同的. 其实对于这一段代码是没有任何疑问的, 可以很轻松的 明白为什么输出的地址不同.
那么编译器是如何处理第一部分代码，使输出的地址相同的。
可以通过gdb调试可以很清晰的看到编译器是如何处理这种情况的。
int array[] = { 0, 1, 2, 3, 4 }; void *a1 = (void *)&amp;array, *a2 = (void *)array; 可以看到void这一行的汇编代码为:
0x565561e4 &lt;main+71>: lea 0x8(%esp),%eax 0x565561e8 &lt;main+75>: mov %eax,(%esp) 0x565561eb &lt;main+78>: lea 0x8(%esp),%eax 0x565561ef &lt;main+82>: mov %eax,0x4(%esp) 0x565561f3 &lt;main+86>: mov $0x0,%eax 可以看到不管是 array 还是 &amp;array 的操作都是使用的 lea 操作将 0x8(%esp) 移动到 %eax 中然后在 mov 操作赋值到相关变量中.
而对于另一段代码:
int **array = (int **)malloc(sizeof(int *) * 5); for (int i = 0; i &lt; 5; i++) array[i] = (int *)malloc(sizeof(int)); void *a1 = (void *)&amp;array, *a2 = (void *)array; 0x56556214 &lt;main+103>: lea -0x2c(%ebp),%eax 0x56556217 &lt;main+106>: mov %eax,-0x24(%ebp) 0x5655621a &lt;main+109>: mov -0x2c(%ebp),%eax 0x5655621d &lt;main+112>: mov %eax,-0x20(%ebp) 0x56556220 &lt;main+115>: mov $0x0,%eax 可以看到在为 a2 赋值是使用的是 mov 指令而不是 lea 指令.
...</p></div><a class=entry-link aria-label="post link to 关于数组array和&array地址相同问题" href=https://jiaoshijie.github.io/posts/about_array_addree_question/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>'二维数组', '指针数组'和'指针的指针'的内存布局</h2></header><div class=entry-content><p>开始 下面提到的变量均是在 main 函数中申请的变量。
文中代码
1. 二维数组 首先讨论二维数组, 他在内存中的布局是最简单的, 考虑如下变量
char str[][5] = { "jiao", "_shi", "_jie", }; 可以通过如下代码打印各个部分的地址
printf("str addr: %p\n\n", &amp;str); for (int i = 0; i &lt; 3; i++) { printf("str[%d] addr: %p\t", i, &amp;str[i]); } printf("\n\n"); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 5; j++) { printf("str[%d][%d] addr: %p\n", i, j, &amp;str[i][j]); } printf("\n"); } 可以看到地址从str[0][0]开始到结束是从低到高连续的。因为是在main函数中申请的 这个二维数组，因此它被存储在栈空间中(栈空间地址是高地址到低地址走的)，存储布局 大致如下：
2. 指针的指针 使用如下代码申请指针的指针的空间:
char **d_ptr = (char **)malloc(sizeof(char *) * 3); for (int i = 0; i &lt; 3; i++) { d_ptr[i] = (char *)malloc(sizeof(char) * 5); } memcpy(d_ptr[0], "jiao", 5); memcpy(d_ptr[1], "_shi", 5); memcpy(d_ptr[2], "_jie", 5); 使用如下代码输出各个部分的地址:
printf("d_ptr addr: %p\n\n", &amp;d_ptr); for (int i = 0; i &lt; 3; i++) { printf("d_ptr[%d] addr: %p\n", i, &amp;d_ptr[i]); } printf("\n\n"); for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 5; j++) { printf("d_ptr[%d][%d] addr: %p\n", i, j, &amp;d_ptr[i][j]); } printf("\n"); } 可以看到只有d_ptr的地址是在栈空间中的, 其余部分均是在堆空间中.
...</p></div><a class=entry-link aria-label="post link to '二维数组', '指针数组'和'指针的指针'的内存布局" href=https://jiaoshijie.github.io/posts/doublearray_and_pointer2pointer_in_c/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://jiaoshijie.github.io/tags/c/page/2/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://jiaoshijie.github.io/>Jsj's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>